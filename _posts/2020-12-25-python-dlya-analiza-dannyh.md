---
layout: post
title: Основы Numpy, Scipy, Pandas
comments: False
category: python
tags:
---

# Numpy

```python
import numpy as np
x = np.array([1, 2, 4]) # простой массив
x
>>> array([1, 2, 4])
x.dtype # какие данные хранятся в массиве
>>> dtype('int64')
```

```python
x = np.array([1, 2, 4], dtype='float32') # задали тип данных
x
>>> array([1., 2., 4.], dtype=float32)
x.shape # узнать размерность массива
>>> (3,)
```

Атрибут **shape** возвращает набор размерности по всем осям,
которые у нас есть в массиве, то есть если бы это был какой-то двумерный массив, у нас бы вернулась пара число строк и число столбцов, но в данном случае у нас получается одномерный массив и возвращается только одно значение. 

**Двумерная матрица**

```python
m = np.array([[1, 2, 4], [3, 2, 1]]) # передаем лист с литами
m
>>> array([[1, 2, 4],
>>>       [3, 2, 1]])
m.shape
>>> (2, 3)
```

Numpy массивы можно создавать несколькими способами. Прежде был лист на основе листа.


Также можно создать массивы на основе встроенной функции.

```python
# единичная
np.ones(3)
>>> array([1., 1., 1.])

# нулевая
np.zeros(3)
>>> array([0., 0., 0.])

# диагональная
np.eye(4)
>>> array([[1., 0., 0., 0.],
>>>       [0., 1., 0., 0.],
>>>       [0., 0., 1., 0.],
>>>       [0., 0., 0., 1.]])

# со случайными числами
np.random.random([2,3])
>>> array([[0.31382662, 0.23470768, 0.40722605],
>>>       [0.0262462 , 0.49801116, 0.58328842]])
```

## Взаимодействие с массивом

**Как работает индексация в numpy**

Если же у нас какой-то одномерный массив, мы можем просто выбрав нужный нам индекс, вытащить значения, и соответственно, так же как с листом, индексация начинается с нуля

```python
x = np.array([1, 2, 4])
x[2]
>>> 4
```

В двумерной матрице

```python
y = np.array([[1, 2, 3],[4, 5, 6]])
# первый в квадратных скобках индекс по оси Х
# второй по Y
y[0,1]

## Промежуток индексов ##
# первое строки, второе столбцы
y[:, :2] 
>>> array([[1, 2],
>>>       [4, 5]])

## Значения по условию ##
# маска
y = np.array([[1, 2, 3],[4, 5, 6]])
y > 2
>>> array([[False, False,  True],
>>>       [ True,  True,  True]])

# маску передаем как индекс
y[y>2]
>>> array([3, 4, 5, 6])
```

### изменение размерности матрицы

При работе с многомерными массивами, у нас часто возникает ситуация, что нам необходимо как-то поменять форму, либо размерность данных, например, если у нас была какая-то многомерная структура, мы хотим ее развернуть в один массив, одномерный, и посмотреть какие-то значения. В numpy это можно осуществить, используя следующие методы: **flatten** и **reshape**. 

```python
b = np.array([[3, 1, 2, 5], [6, 8, 9, 7]])

b.shape
>>> (2, 4)

b.flatten()
>>> array([3, 1, 2, 5, 6, 8, 9, 7])

b.T
>>> array([[3, 6],
>>>       [1, 8],
>>>       [2, 9],
>>>       [5, 7]])

b.reshape((4, 2)) # значения по осям
>>> array([[3, 1],
>>>       [2, 5],
>>>       [6, 8],
>>>       [9, 7]])
```

Используя метод **resize**,
можно поменять форму нашего исходного массива.
Отличие **resize** от **reshape** заключается в том,
что **resize** автоматически меняет
исходный массив в то время как **reshape** просто изменяет ее форму. 

```python
b.resize(4,2)
b
>>> array([[3, 1],
>>>       [2, 5],
>>>       [6, 8],
>>>       [9, 7]])
```

**Математические операции**

```python
v = np.array([9, 10])
w = np.array([22, 10])

v+w
>>> array([31, 20])

v*w
>>> array([198, 100])

np.dot(v, w) # скалярное произведение
>>> 298
```

# Scipy

Библиотека **scipy** очень удобная библиотека для различного рода вычислений. Она включает в себя методы оптимизации, методы линейной алгебры, обработки сигналов и изображений. 

## Нахождение детерминанта матрицы, обратной матрицы, собственные числа и вектора

```python
from scipy import linalg
from scipy import optimize
import numpy as np
import matplotlib.pyplot as plt

A = np.array([[1, 3, 5],[2, 5, 1],[2, 3, 8]])
linalg.det(A)
>>> -25.000000000000004
# Детерминант не равен нулю
# найдем обратную матрицу

linalg.inv(A)
>>> array([[-1.48,  0.36,  0.88],
>>>        [ 0.56,  0.08, -0.36],
>>>        [ 0.16, -0.12,  0.04]])

# метод возвращает пару, где 1-собственные числа, 2-собственные вектора
eigenvalues, eigenvectors = linalg.eig(A)
eigenvalues
>>> array([10.5540456 +0.j, -0.5873064 +0.j,  4.03326081+0.j])

eigenvectors
>>> array([[-0.51686204, -0.94195144,  0.11527992],
>>>        [-0.32845853,  0.31778071, -0.81936883],
>>>        [-0.79054957,  0.10836468,  0.56155611]])
```

## Оптимизация

```python
def f(x):
    return x**2 + 6*np.sin(x)
x = np.arange(-10,10,0.1)
plt.plot(x, f(x))
plt.show()
```

<img src="/assets/img/2020-12-25-python-dlya-analiza-dannyh/1.png">