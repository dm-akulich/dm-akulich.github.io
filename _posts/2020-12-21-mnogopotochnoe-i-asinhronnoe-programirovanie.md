---
layout: post
title: Многопоточное и асинхронное программирование в Python (Crs. Погружение в Python)
comments: False
category: python
tags:
---

# 1. Процессы и потоки

**Выполнение асинхронных программ их выполнение в процессах и потоках.**

## 1.1. Процесс и его характеристики

### Что такое процесс

Процесс — это программа, которая запущена в оперативной памяти компьютера.

Процесс — это набор инструкций, которые выполняются последовательно.

### Процессы в ОС

Характеристики процесса:

- Идентификатор процесса, PID
- Объем оперативной памяти
- Стек - Стек используется для вызова функций, для создания локальных переменных у этих функций.
- Список открытых файлов
- Ввод/вывод

В общем случае процессы в ОС выполняются последовательно. Планировщик ОС выделяет небольшие кванты времени каждому процессу, последовательно выполняет один процесс и переключается на выполнение следующего процесса.

### Запуск процесса в Python

```python
import time
import os

pid = os.getpid() # получим id процесса

while True:
    print(pid, time.time())
    time.sleep(2)
```

## 1.2. Создание процессов

Как создать дочерний процесс в Python, как работает системный вызов ```fork```, примеры создания процессов при помощи модуля ```multiprocessing```.

Процесс в операционной системе создается при помощи системного вызова ```fork```. Рассмотрим программу, которая создает дочерний процесс при помощи системного вызова ```fork```.

```python
# Создание процесса на Python
import time
import os

pid = os.fork()

if pid == 0:
    # дочерний процесс
    while True:
        print("Child process:", os.getpid())
        time.sleep(5)
else:
    # родительский процесс
    print("Parent process:", os.getpid())
    os.wait()

>>> "Parent process: 1252"
>>> "Child process: 1253"
>>> "Child process: 1253"
```

Системный **вызов ```fork``` создает точную копию родительского процесса**. Это означает, что вся память, все файловые дискрипторы и все ресурсы, которые были доступны в родительском процессе, будут целиком и полностью скопированы в дочернем процессе. То есть после того, как системный вызов ```fork``` отработал, с этого момента у нас два процесса в операционной системе. Единственное отличие заключается в том, что системный вызов ```fork``` в родительский процесс вернет ```pid``` дочернего процесса, а в дочернем процессе переменная ```pid``` будет равна нулю. Код, который находится за веткой ```else```, будет исполнен в родительском процессе. Итак, в родительском процессе мы вызываем системный вызов ```os.wait```, это еще один дополнительный системный вызов и он позволяет нам дожидаться завершения дочернего процесса созданного. А в дочернем процессе в бесконечном цикле выводим ```pid``` нашего процесса, который создали, и спим пять секунд.

Запустим код в терминале

<img src="/assets/img/2020-12-21-mnogopotochnoe-i-asinhronnoe-programirovanie/1.png">

## 1.3. Создание потоков

## 1.4. Синхронизация потоков

## 1.5. Глобальная блокировка интерпретатора




# 2. Работа с сетью, сокеты

**То, как устроены socket'ы, и выполнение различных сетевых запросов.**

## 2.1. Сокеты, клиент-сервер
## 2.2. Таймауты и обработка сетевых ошибок
## 2.3. Обработка нескольких соединений





# 3. Асинхронное программирование

**То, как устроены генераторы и корутины в языке Python и рассмотрим примеры работы с frameworkom asyncio**

## 3.1. Исполнение кода в одном потоке, модуль select
## 3.2. Итераторы и генераторы. В чем разница?
## 3.3. Генераторы и сопрограммы
## 3.4. Asyncio - начало
## 3.5. Работа с Asyncio


