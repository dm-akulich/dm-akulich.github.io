---
layout: post
title: Метаклассы (Crs. Погружение в Python)
comments: False
category: python
tags:
---

Определим класс с названием Class и его объект. Тип нашего объекта является Class, потому что Class создал наш объект. Однако, у класса тоже есть тип. Этот тип type, потому что type создал наш класс. В данном случае type является мета-классом. Он создаёт другие классы. Типом самого type, кстати, является он же сам. 

```python
class Class:
    pass

obj = Class()

print(type(obj))
>>> "<class '__main__.Class'>"
print(type(Class))
>>> "<class 'type'>"
print(type(type))
>>> "<class 'type'>"
print(issubclass(Class, type))
>>> "False"
print(issubclass(Class, object))
>>> "True"
```

Очень важно понимать разницу между созданием и наследованием. В данном случае класс не является subclass'ом type. Type его создаёт, но класс не наследуется от него. Класс наследуется от класса объекта.

Они создаются с помощью мета-классов, и в данном случае давайте определим свой собственный мета-класс, который будет управлять поведением при создании класса. Мы определим класс Meta. Для того чтобы он бы мета-классом, он должен наследоваться от другого мета-класса. В данном случае это мета-класс **type**, базовый мета-класс. И, как вы уже знаете, метод ```_new_``` управляет поведением при создании объекта.
В данном случае объектом является другой класс, поэтому мы можем изменять поведение при создании другого класса. Метод ```_new_``` принимает название класса, его родителей и какие-то атрибуты. Мы можем определить какой-то новый класс A и указать, что его мета-классом является наш мета-класс.
Именно этот мета-класс и будет управлять поведением при создании нового класса.
В данном случае мы выводим строчку о том, что у нас класс создаётся. При определении class у нас вызывается мета-класс и функция ```_new_```, метод ```_new_```. Мы выводим, что у нас наш класс создаётся. Записываем в какой-то атрибут нашего класса, в данном случае в атрибут class_id, значение.
Таким образом, мы можем переопределить поведение при создании класса. 

```python
class Meta(type):
    def __new__(cls, name, parents, attrs):
        print('Creating {}'.format(name))

        if 'class_id' not in attrs:
            attrs['class_id'] = name.lower()

        return [super().__new__(cls, name, parents, attrs)]

class A(metaclass=Meta):
    pass

>>> Creating A
```

## Абстрактные методы

В данном случае здесь также работают мета-классы и мы можем определить абстрактный какой-то класс с методом abstractmethod. О чём говорит наш декоратор abstractmethod? Что у нас не получится создать какой-то класс, не определив этот метод. То есть у нас метод абстрактный и мы обязаны его переопределить в классе, который наследуется от нашего класса. В данном случае у нас Child не переопределяет метод send, и поэтому вызывается ошибка. Если мы переопределим метод send, то всё будет, как мы хотели, у нас абстрактный метод переопределён, всё работает. 

```python
# abstract.py
from abc import ABCMeta, abstractmethod

class Sender(metaclass=ABCMeta):
    @abstractmethod
    def send(self):
        """Do something"""
        pass

class Child(Sender): pass

Child()
>>> "TypeError: Can't instantiate abstract class Child with abstract method send"
```
