---
layout: post
category: python
title: 'Что такое yield и функции генераторы'
---

У нас есть две функции, имеющие одинаковый смысл.

```python
# простая функция
def countdown_simple(n):
    result = []
    while n != 0:
        result.append(n)
        n -= 1
    return result

print('Simple func result', countdown_simple(4))

>>> Simple func result [4, 3, 2, 1]

# функция генератор
def countdown_gen(n):
    while n != 0:
        yield n - 1
        n -= 1

g = countdown_gen(4)
print(next(g))
print(next(g))
print(next(g))
>>> 3
>>> 2
>>> 1
```

**Разница** в том, что обычная функция хранит промежуточное состояние своей работы в виде списка. **Список** в данном случае типа **аккумулятор** промежуточного результата. И когда функция отработает полностью этот список целиком возвращается в то место, откуда мы ее вызывали. При повторном обращении к этой простой функции генерация чисел происходит заново.

Во втором же случае оператор yield генерирует и возвращает результат частями по одному элементу. Это как return, только возвращает результат частями. Локальные переменные как бы сохраняют свое состояние.

Преимущество генератора в том, что мы не тратим ресурсы на храение ни промежуточного результат, ни итогового.

Списки стоит использовать, если мы планируем обращаться к элементам списка много раз.

Генераторы не позволяют обращаться по индексу. Использовать генераторы стоит, если мы планируем обрабатывать очень большие последовательности данных и при этом мы не знаем понадобятся ли нам все данные или только часть.






























12
