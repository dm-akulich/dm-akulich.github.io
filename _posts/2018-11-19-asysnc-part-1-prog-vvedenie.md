---
layout: post
title: 'Асинхронность в Python #1 Введение'
category: python
---

Речь пойдет об асинхронном коде, который фыполняется в рамках одного потока и в рамках одного процесса. Все будем делать в рамках одного потока. Все примеры здесь очень сильно упрощены.

Существует два типа задач:
 
- Первый тип задач связан с процессорами CPU и GPU. Это различные вычисления, рендеринг и тп
- Второй тип задач - те задачи, которые завязаны на вводе данных и выводе IO задачи (Input и Output). Также к этой категории задач можно отнести все что касается записи, чтения с файлов и тп. Работа с БД, работа с сетью.

Асинхронное программирование применяется в первую очередь к задачам второй категории, в данном примере для работы с сокетами.

*Примечание*: сокет - это пара ```domain:5000```, то есть домен и порт, через сокет осуществляется взаимодейсвтие между двумя субъектами: клиентом и сервером.

Начнем с описания субъекта сервера, того кто будет обслуживать клиента.


```python
import socket
# определяем сокет, AF_INET - IP протокол 4-й версии
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# чтобы порт можно было переиспользовать и не было тайм аута
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# связываем серверный сокет с конкретным адресом и конкретным портом
server_socket.bind(('localhost', 5000))
# даем команду на прослушку
server_socket.listen()

while True:
    print('Before accept()')
    client_socket, addr = server_socket.accept()
    print('Connection from', addr)

    while True:
        print('Before recv()')
        request = client_socket.recv(4096)
        
        if not request:
            break
        else:
            response = 'Hello World\n'.encode()
            client_socket.send(response) 
    sclient_socket.close()
```

# Подключение к серверному сокету

Подключимся к нашему серверу

```bash
# server
➜  async python original.py
Before accept()
```

Скрипт вошел в цикл и остановил свое выполнение перед функцией acctpt(), он ждет подключение. И выполнение скрипта не продвинется ни на одну строчку, пока подключения не будет. 

В данном случае функция accept() - это блокирующая функция. 

# Подключение первого клиента

Подключим клиента c другого окна в консоли

```bash
# client 1
➜  ~ nc localhost 5000
```

В свою очередь серврем принял отбращение

```bash
➜  async python original.py
Before accept()
Connection from ('127.0.0.1', 49987)
Before recv()
```

Теперь выполнение скрипта дошло до функции recv() и остановилось. Серверный сокет ждет, что мы ему что-нибудь напишем. Напишем ему "Hi?"

```bash
# client 1
➜  ~ nc localhost 5000
hi ?
Hello World
```

В ответ он нам вернул hello world, а сам сервер опять ждет чего-нибудь от клиента в цикле с recv(). В данном случае функция recv() - блокирующая функция.

```bash
➜  async python original.py
Before accept()
Connection from ('127.0.0.1', 50043)
Before recv()
Before recv()
```

Ответ мы получили без задержки, потому что буфер отправки пустой.

## Второй клиент

При подключении второго клиента сервер ничего не возвращает, потому что он занят первым клиентом.

**screen-1**

Мы постоянно ждем ответа первого клиента и не можем подняться на цикл выше, чтобы принять подключение второго клиента.


Чтобы принять второе подключение нужно было как-то передать контроль выполнения программы, и нужен был бы какой-то код-менеджер, который бы рулил процессом (тот код, в который и передается контроль выполнения программы в период ожидания, пока клиент что-то думает). И это тот кусок кода, который бы решил что делать дальше. Этот код называют **событийным циклом (event loop)**.

Асинхронный код без сторонних библиотек можно писать тремя способами: 
- С помощью коллбэков
- С помощью генераторов event routine
- С помощью синтаксиса async avate








