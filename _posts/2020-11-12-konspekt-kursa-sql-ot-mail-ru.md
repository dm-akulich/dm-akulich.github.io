---
layout: post
title: Конспект курса Использование баз данных от Mail.ru
comments: False
category: sql
tags: sql
---

БД

Реляционные (SQL) - появились раньше
- MySQL
- PostgreSQL
- Oracle
- MS SQL

Нереляционные (noSQL) - NotOnlySQL
- Cossandra
- MongoDb

**Схемы**

*Немного про прозводительность*

Если мы допустим хотим сделать операцию, где ```group_id``` - внешний ключ.

```sql
INSERT INTO students(fname, group_id) VALUES ('Vova', 3);
```

То на самом деле, сначала происходит 

```sql
SELECT FROM group
WHERE group_id = 3;
```

И только потом срабаотывает ```INSERT INTO```.

Зная это, можно оптимизировать запрос.

Допустим, у нас есть запрос

```sql
SELECT COUNT(*) FROM student AS s,
INNER JOIN group AS g
ON s.group_id=g.group_id
WHERE s.name = 'Vova' OR s.name = 'Alexey';
```

Если мы знаем что у нас такой констреинт, что не может быть студента с несуществующей группой, то ```INNER JOIN``` можем убирать.

**Пример 2:**

Допустим есть таблица группы

| **group** |
-------------
| id INT |
| name VARCHAR(10) UNIQUE |

и мы делаем 

```sql
INSERT INTO group(name)
VALUES ('2342')
```

Мы сча ожидаем, что если в базе уже есть группа 2342, то запрос должен падать

Что должна делать БД, чтоб упасть? сделать у себя внутренний SELECT

```sql
SELECT (name)
FROM WHERE name='2342'
```

Чтобы этот селект сделать быстрым, мы можем **отсортировать** либо **хэши**.

Чаще всего работают с индексами. Поиск по хеш-таблице - O(1); поиск по дереву - O(n*logn)

Оч важный констрейнт это **CHECK**, который проверяет какие данные мы хотим заинсертить. Допустим, можем прописать какой-нибудь regex, который будет проверять нормальная ли электронная почта к нам пришла (должна быть точка, собака, домен и тп.)

**Как рабоатет СУБД (принцип)**
1. Мы пишем сложный запрос
2. Это запрос идет в БД
3. Оптимизатор смотрит на схему, парсит SQL
4. Далее строится план выполения запроса (императивная шутка в духе пойди туда, сделай это и тп.)
5. Далее этот план отдается какому-то выполнятору
6. Этот екзекьютор идет к данным, смотрит что нужно
7. И отдаем данные пользователю

### Что такое индекс

Индекс - это структура данных, которая представляет собой чаще всего дерево, которое позволяет делать быстрый поиск.

Из важного про индекс, что если у нас задана какая-либо колонка с констрейнтом INDEX, то, выполняя операцию

```sql
INSERT INTO group(name) VALUES (2434);
```

на самом деле выполняется две операции INSERT: в таблицу и в индекс

```sql
INSERT INTO group...
INSERT INTO index...
```

**Дизайн схем**

Важное:
1. Существует три вида отношений
    - 1 к 1
    - 1 к N - много студентов учится в одной группе (student.group_id=group.id)
    - N к M - многие ко многим развязывается через **три таблички**.

Пример связи N к M. Мы хотим знать какие у фильмов конкретные теги.

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/1.png">

Третья таблица называется **таблица связки**, сама по себе она не сущность. Можем задать еще констреинт на уникальность для треттьей таблицы, чтобы не было у одного фильма одинаковых тегов.

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/2.png">

Запрос к такой БД может быть следующий

```sql
SELECT f.title, t.tag_name FROM film f
INNER JOIN film_tag ft ON f.id=ft.film_id INNER JOIN tag t ON ft.tag_id=t.id;
```

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/3.png">

### Запросы

**Порядок выполнения**
5. SELECT - выбираем какие-то колонки.
1. FROM - 
2. WHERE - 
3. GROUP BY - 
4. HAVING - 
6. ORDER BY - 

В селекте у нас могут быть константы, выражения, **подселект**. Почти в любых местах может быть селект.

```sql
SELECT name, (SELECT group FROM group)
FROM table_A; // теперь у нас будет таблица, в которой будут поля name и group.
```

Еще в селекте можно написать ```CASE```. Могут быть и кейсы вложенные в кейс.

```sql
CASE
    WHEN name 'Vova'
    THEN 'cool'
    ELSE 'not'
END AS status // тогда это сохраниться в отдельную колонку.
```

```FROM``` в самом простом случае тут может быть просто таблица. Могут быть джоины

```sql
FROM students INNER JOIN group
ON students.group_id=group.id;
```

Помимо ДЖОИНОВ в ФРОМЕ тоже может быть СЕЛЕКТ. То есть **вместо имени таблички у нас может быть подзапрос с определенным именем**.

```sql
SELECT * FROM tableA as t LEFT JOIN
    (SELECT name FROM students
        WHERE nick='best' AS d2) ON t.id=d2.id
```

```WHERE``` - типа фильтр и тут тоже могут быть позапросы.

```sql
FROM students AS s
WHERE name='Vova' and group.id IN (SELECT group_id FROM group AS g WHERE g.faculty='FMK')
```

Особенность INNER JOIN: если у нас есть два поля по которым мы джоинимся, и в одном из полей есть дубль, то заджинится два раза и будет дубль.


#### Связь многие-ко-многим

Связь многие-ко-многим создается с помощью трех таблиц. Две таблицы – “источника” и одна соединительная таблица. Первичный ключ соединительной ```таблицы A_B``` – составной. Она состоит из двух полей, двух внешних ключей, которые ссылаются на первичные ключи таблиц ```A``` и ```B```.

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/4.png">

Все первичные ключи должны быть уникальными. Это подразумевает и то, что комбинация полей A и B должна быть уникальной в ```таблице A_B```.

#### Другой пример связи многие-ко-многим: заказ билетов в отеле.

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/5.png">


Соединительная таблица связи многие-ко-многим имеет дополнительные поля.

В этом примере вы видите, что между таблицами гостей и комнат существует связь многие-ко-многим. Одна комната может быть заказана многими гостями с течением времени и с течением времени гость может заказывать многие комнаты в отеле. Соединительная таблица в данном случае является не классической соединительной таблицей, которая состоит только из двух внешних ключей. Она является отдельной сущностью, которая имеет связи с двумя другими сущностями.

Вы часто будете сталкиваться с такими ситуациями, когда совокупность двух сущностей будет являться новой сущностью.


### Модель БД интернет-магазина

Для того, чтобы получить представление о данных, которые будут использоваться, давайте обозначим задачи, которые должен выполнять интернет-магазин.

- Отображение товаров
- Классификация товаров
- Регистрация клиентов
- Добавление товаров в корзину покупок
- Отображение содержимого корзины покупок
- Оформление заказов посетителями
- И т.д.

#### Сущности и отношения

Из списка задач мы можем вывести сущности, которые имеют важные роли в нашей системе. **Товары, категории, клиенты** и **заказы** – сущности, которые можно найти почти в каждой базе данных интернет-магазина. В данном примере я покажу вам модель, содержащую только следующие сущности: **клиент, заказ** и **товар**. Определившись с сущностями, мы можем подумать над связями между ними.

- Между **заказом** и **товаром** существует **связь многие-ко-многим**. Каждый заказ содержит 1 или более товаров и каждый товар может быть связан с 0, 1 или большим количеством заказов. Связь многие-ко-многим создается с помощью трех таблиц. Две таблицы – источники данных (order — заказ и products — товары) и одна – соединительная (OrderProducts), что вы и можете увидеть на картинке ниже. Обратите внимание на то, что и заказы и товары имеют связь один-ко-многим с соединительной таблицей. Вместе они образуют связь многие-ко-многим между заказами и товарами.
- Клиенты и заказы имеют связь один-ко-многим. Каждая запись о клиенте может быть связана с множественными записями о заказах (заказами) и наоборот, каждая запись о заказе (конкретный заказ) может быть связана только с одной записью о клиенте.

<img src="/assets/img/2020-11-12-konspekt-kursa-sql-ot-mail-ru/6.png">

Некоторые замечания о данной модели.

#### Таблица заказов (order)

Каждая запись таблицы заказов, каждый заказ связан с уникальной записью о клиенте, с уникальным клиентом с помощью внешнего ключа – поля customer_id.

*Количество заказов.*

Если вы задались вопросом, а можете ли вы добавить, например, поле количества заказов (order_quantity), то ответ – нет. Эти данные могут быть **получены из существующих данных**. Общее количество товаров в заказе (order_quantity) может быть получено из таблицы OrderProduct. Запрос, который находит количество товаров в заказе может быть легко сформирован с помощью SQL.

*Тип платежа.*

Поле, которое вы могли бы добавить в таблицу заказов – payment_type (тип платежа). Это информация уникальна для конкретного заказа и не может быть получена из других данных (имейте в виду, что поле payment_type стало бы внешним ключом в таблице заказов – order – с сылкой на отдельную таблицу, содержащую типы платежей).

*Общая сумма заказа.*

Еще одно поле, которое вы можете (а возможно и должны) добавить в таблицу order – это поле для общей суммы заказа. Но вы можете подумать, что эти данные мы можем получить из существующих. Вы ведь можете сложить стоимости всех товаров заказа? Да. И нет. Цена товара – это величина изменяемая. Поэтому когда вы подсчитаете общую стоимость заказа, сложив стоимости каждого его товара, а владелец магазина удвоит стоимость одного из товаров в заказе, то и общие стоимости всех уже выполненных заказов тоже изменятся. Иначе говоря, если высчитывать общую стоимость заказа при просмотре, а цены на товары могут меняться, то при этом самом просмотре истории может возникнуть такая ситуация, когда количество денег, которые вы заплатили за весь заказ, будет меняться. Вот почему лучше высчитывать общую стоимость в момент оформления заказа и хранить ее в таблице order.

*Хранение истории цен на товары.*

Говоря про историю, можно предположить, что вам может понадобится сохранять и историю цен на каждый товар. В этом случае вы бы могли посмотреть на дату заказа, сделать запрос к таблице price_history (история цен) и получить стоимость товара на дату оформления заказа. В данном случае вам не пришлось бы хранить общую стоимость заказа в таблице order. Я полагаю, что большинство интернет-магазинов сохраняют общую стоимость товаров заказа и не хранят историю цен на эти товары. Но, если говорить про вас, то разработчик вы и вам решать делать это или нет.












































