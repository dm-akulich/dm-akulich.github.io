---
layout: post
title: Магические методы классов (Crs. Погружение в Python)
comments: False
category: python
tags:
---

Магический метод — это метод, определённый внутри класса, который начинается и заканчивается с двух подчёркиваний. Например, магическим методом является метод ```__init__```, который отвечает за инициализацию созданного объекта.

Ещё одним магическим методом является метод ```__new__```, который отвечает за то, что происходит в момент создания объекта класса. Метод ```__new__``` возвращает только что созданный объект класса и может как-то переопределять поведение при создании. Например, можно создать класс **Singleton**, который гарантирует то, что объект может быть создан только один от этого класса. 

```python
class Singleton:
    instance = None

    def __new__(cls):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        
        return cls.instance

a = Singleton()
b = Singleton()

a is b
>>> True
```

# __str__

Метод ```__str__```, который определяет поведение, например, при вызове функции **print**. Метод ```__str__``` должен определить какое-то человекочитаемое описание нашего класса, которое может вывести потом пользователь где-то, например, в интерфейсе. Классическим вариантом метода ```__str__``` может быть выведение имени и имейла. Обратите внимание, мы используем тот же самый класс, что и раньше, но теперь, если мы будем принтить наш объект, у нас будет не какой-то **object** типа **user**, а понятное и читаемое название нашего объекта.

```python
class User():
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def __str__(self):
        return '{} <{}>'.format(self.name, self.email)

jane = User('Jane Doe', 'jane.doe@mail.com')

print(jane)

>>> 'Jane Doe <jane.doe@mail.com>'
```

# __hash__, __eq__

```__hash__``` и equal, ```__eq__```, которые определяют то, как сравниваются наши объекты и что происходит при вызове функции hash. Магический метод ```__hash__``` может, например, переопределить функцию хеширования, которая используется, например, когда мы получаем ключи в словаре. В данном случае нашего класса user мы можем сказать, что при вызове функции ```__hash__``` мы хотим хешировать имейл, то есть у нас в качестве хеша берётся всегда имейл пользователя. Ну а при сравнении мы эти имейлы просто сравниваем, при сравнении двух объектов. Таким образом, если мы создадим двух юзеров с разными именами, но одинаковыми имейлами, при вызове функции сравнения, то есть когда мы используем **==**, Python будет говорить нам, что это один и тот же объект, потому что вызывается метод ```__eq__```, который сравнивает только имейлы. Точно так же функция ```__hash__``` возвращает теперь одно и то же значение, потому что используется значение имейла, которое в данном случае одинаковое. Но если мы попробуем создать словарь, где в качестве ключа будет использоваться наш объект юзера, то у нас создастся словарь только с одним ключом, а не с двумя объектами, несмотря на то, что мы итерируемся здесь по двум объектам, потому что в качестве хеша используется одно и то же значение, и в качестве ```__eq__``` у нас сравниваются имейлы. 

```python
class User():
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def __str__(self):
        return '{} <{}>'.format(self.name, self.email)

    def __hash__(self):
        return hash(self.email) # в качестве хеша берем е-маил

    def __eq__(self, obj):
        return self.email == obj.email

jane = User('Jane Doe', 'j.doe@mail.com')
joe = User('Joe Doe', 'j.doe@mail.com')

print(jane == joe)
>>> True

print(hash(jane))
print(hash(joe))
>>> '-9120845205008571694'
>>> '-9120845205008571694'
```

# __getattr__, __getattribute_, __setattr__, __delattr___

Методы, определяющие доступ к атрибутам. Это методы ```__getattr__``` и ```__getattribute__```. Очень важно понимать между ними отличия, потому что очень часто происходит путаница. Итак, **метод ```__getattr__``` определяет поведение, когда наш атрибут, который мы пытаемся получить, не найден**. Таким образом, если мы обратимся к атрибуту какого-то объекта и у нас он будет не найден, у нас всегда вызовется метод ```__getattr__``` и мы можем определить какое-то поведение дефолтное при той ситуации, когда атрибута нет. **Метод ```__getattribute__``` вызывается в любом случае.** Когда мы обращаемся к какому-то атрибуту, у нас всегда вызывается метод ```__getattribute__```, и мы можем, например, логировать какие-то обращения к атрибутам или переопределять поведение при поиске соответствующих атрибутов объекта. Например, мы можем возвращать всегда какую-то строчку и ничего не делать, как в данном случае. Мы определили класс и переопределили метод ```__getattribute__```, который всегда возвращает строку и ничего дальше не делает. Таким образом, что бы мы не делали, как бы мы не пытались обращаться к атрибутам, даже которых ещё нет, как в данном случае, у нас всегда выведется эта строка. 

```python
class Researcher:
    def __getattr__(self, name):
        return 'Nothing found -__-'

    def __getattribute__(self, name):
        return 'nope'

obj = Researcher()
print(obj.custom_attribute)
>>> nope
```

```__getattr__``` работает немного по-другому. **```__getattr__``` вызывается в том случае, если атрибут не найден.** В данном случае внутри ```__getattribute__```, который вызывается всегда, мы просто логируем, что мы пытаемся найти соответствующий атрибут и продолжаем выполнение, используя класс object. Таким образом, если у нас пытается найтись атрибут, которого не существует, у нас вызовется ```__getattr__```, что здесь и происходит. У нас ничего не найдено. 

```python
class Researcher:
    def __getattr__(self, name): # вызывается, если атрибут не найден
        return 'Nothing found -__-'

    def __getattribute__(self, name): # вызывается в любом случае
        print('Looking for {}'.format(name))
        return object.__getattribute__(self, name)

obj = Researcher()
print(obj.custom_attribute)

>>> 'Looking for custom_attribute'
>>> 'Nothing found -__-'
```

**```__setattr__``` определяет поведение при присваивании значения к атрибуту.** Например, вместо того, чтобы присвоить значение, мы можем опять же вернуть какую-то строчку и ничего не делать. В данном случае, если мы попытаемся присвоить значение атрибуту, у нас ничего не произойдёт и атрибут не создастся.

```python
class Ignorant:
    def __setattr__(self, name, value):
        print('Not gonna set {}'.format(name))

obj = Ignorant()
obj.math = True

>>> 'Not gonna set math!'
```

Ну а ```__delattr__``` управляет поведением, когда мы пытаемся удалить какой-то атрибут объекта. Мы можем не удалять, а, например, переопределить как-то поведение или добавить какую-то функциональность. Например, если мы хотим каскадно удалить какие-то объекты, связанные с нашим классом. В данном случае мы просто продолжаем удаление с помощью класса object, ну и как-то логируем то, что у нас происходит удаление. 

```python
class Polite:
    def __delattr__(self, name):
        value = getattr(self, name)
        print(f"Goodbye {name}, you were {value}.")

        object.__delattr__(self, name)

obj = Polite()
obj.attr = 10
del obj.attr

>>> 'Goodbye attr, you were 10.'
```
