---
layout: post
title: Конспект курса тренажер SQL
comments: true
category: sql
tags: sql
---

<meta name="robots" content="noindex" />

# 1. Отношение

*Последовательность команд*

```sql
SELECT 'столбцы или * для выбора всех столбцов; обязательно'

FROM 'таблица; обязательно'

WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'

GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'

HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'

ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
```

**Основные принципы реляционных баз данных:**

- все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов, называемых отношением, более распространенное название – таблица;
- в пересечение строки и столбца таблицы можно занести только одно значение;
- все операции выполняются над целыми отношениями и результатом этих операций является отношение.

<img src="/assets/img/2020-06-20-konspekt-trenazher-sql/1.png">

- отношение  – это структура данных целиком, набор записей (в обычном понимании – таблица) , в  примере –это Сотрудник;
- кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А, 234-01-23, программист>, все кортежи в отношении должны быть различны;
- мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
- атрибут – это столбец в таблице (более распространенный термин – поле ), в примере – Табельный номер, Фамилия И.О., Телефон, Должность) 
- размерность – это число атрибутов в таблице, в данном случае – 4;
- размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
- домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута Должность домен – {инженер, программист}.

**Отношение, реляционная модель**

Перед созданием таблицы в базе данных необходимо описать ее структуру. Для этого выполняется следующая последовательность шагов:

1. Дать таблице имя, пусть она будет называться *book*, вот некоторые правила для выбора имен таблиц:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя должно быть уникальным в пределах базы данных.

Также рекомендуется:

- чтобы имя было существительным в единственном числе;
- имя должно быть понятным и соответствовать тому объекту, который оно описывает;
- имя должно быть как можно короче, максимум до 10 символов.

Важно. Имена таблиц являются регистрозависимыми из-за операционной системы на которой работает stepik, то есть имя *book* и *Book* – разные имена. Рекомендуется для записи имен таблиц использовать только строчные (маленькие) буквы.

2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять,  в нашем случае это:

- title – поле для хранения названия книги;
- author – поле с фамилией автора книги ;
- priсe – цена книги;
- amount – количество книг.

Правила по выбору имени поля информационного объекта:

- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;
- имя поля должно быть уникальным в пределах таблицы.

Рекомендации по выбору имени поля информационного объекта:

- имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;
- имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.

3. Включить ключевое поле *book_id*, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.

Рекомендации по именованию  ключевых полей:

- имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id.

### Выбор типов данных для полей 

После описания структуры таблицы необходимо выбрать типы данных для каждого поля.

<table border="1" cellpadding="0" cellspacing="0">
	<tbody>
		<tr style="text-align: center;">
			<td><strong>Тип&nbsp;данных</strong></td>
			<td><strong>Описание</strong></td>
			<td><strong>Пример</strong></td>
		</tr>
		<tr>
			<td><code>INT</code>&nbsp;<br>
			<code>INTEGER</code></td>
			<td>Целое число, могут принимать значения<br>
			от -2 147 483 648 до 2 147 483 647</td>
			<td>-567<br>
			1205</td>
		</tr>
		<tr>
			<td><code>DECIMAL</code><br>
			<code>NUMERIC</code></td>
			<td>Вещественное число,<br>
			в скобках указывается максимальная<br>
			длина числа (включает&nbsp;символы слева и справа от десятичной запятой)<br>
			и количество знаков после запятой.<br>
			Можно использовать оба этих типа, они эквивалентны,<br>
			принимают значения в диапазоне -10<sup>38</sup>+1 до 10<sup>38</sup>-1.<br>
			<code>DECIMAL(4,1)<br>
			&nbsp;NUMERIC(6,3)</code></td>
			<td>&nbsp;<br>
			&nbsp;<br>
			&nbsp;<br>
			34.6<br>
			-3.294</td>
		</tr>
		<tr>
			<td><code>DATE</code></td>
			<td>Дата в формате&nbsp;ГГГГ-ММ-ДД&nbsp;<br>
			<em>26 июля 2020 года<br>
			3 января 2021 года</em></td>
			<td>&nbsp;<br>
			2020-07-26<br>
			2021-01-03</td>
		</tr>
		<tr>
			<td><code>VARCHAR</code></td>
			<td>
			<p>Строка длиной не более 255 символов,<br>
			в скобках указывается максимальная<br>
			длина строки, которая может храниться в поле<br>
			<code>VARCHAR(10)(рассматриваются однобайтовые кодировки,<br>
			для которых число в скобках соответствует максимальному<br>
			количеству символов в строке)</code></p>
			</td>
			<td>&nbsp;<br>
			&nbsp;<br>
			<br>
			пример<br>
			описание</td>
		</tr>
	</tbody>
</table>

**Рекомендации по выбору типов данных для полей таблицы.**

- Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип VARCHAR(25).
- Для описания ключевого поля используйте описание ```INT PRIMARY KEY AUTO_INCREMENT```. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).


### Создание таблицы

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :

- ключевые слова : CREATE TABLE
- имя создаваемой таблицы;
- открывающая круглая скобка «(»;
- название поля и его описание, которое включает тип поля и другие необязательные характеристики;
- запятая;
- название поля и его описание;
- ...
- закрывающая скобка «)».


```sql
CREATE TABLE genre(genre_id INT PRIMARY KEY AUTO_INCREMENT, name_genre VARCHAR(30));
```

### Вставка записи в таблицу

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения. Структура запроса:

- ключевые слова INSERT INTO;
- имя таблицы, в которую добавляется запись;
- открывающая круглая скобка «(»;
- список полей через запятую, в которые следует занести новые данные;
- закрывающая скобка «)»;
- ключевое слово VALUES;
- открывающая круглая скобка «(»;
- список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
- закрывающая скобка «)».

**Пример.** В таблицу, состоящую из двух столбцов добавим новую строку, при этом в ```поле1``` заносится ```значение1```,  в ```поле2``` - ```значение2```.

```sql
INSERT INTO таблица(поле1, поле2) VALUES (значение1, значение2)
3
```

## Выборка данных

**Выборка отдельных столбцов**

```sql
SELECT title as 'Название', amount as 'Стоимость' FROM book;
```

**Выборка данных с созданием вычисляемого столбца**

```sql
SELECT title, author, price, amount, price * amount AS total FROM book;
```

**Выборка данных, вычисляемые столбцы, математические функции**

В SQL реализовано множество  математических функций для работы с числовыми данными. В таблице приведены некоторые из них.

<table border="1" cellpadding="1" cellspacing="1">
	<thead>
		<tr style="text-align: center;">
			<td><strong>Функция</strong></td>
			<td><strong>Описание</strong></td>
			<td><strong>Пример</strong></td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>ceiling(x)</code></td>
			<td>возвращает наименьшее целое число, большее или равное <strong>x</strong></td>
			<td><code>ceiling(4.2)=5<br>
			ceiling(-5.8)=-5</code></td>
		</tr>
		<tr>
			<td><code>round(x, k)</code></td>
			<td>округляет значение <strong>x</strong> до <strong>k</strong> знаков после запятой,<br>
			если <strong>k </strong>не указано –<strong> x</strong> округляется до целого</td>
			<td><code>round(4.361)=4<br>
			round(5.86592,1)=5.9</code></td>
		</tr>
		<tr>
			<td><code>floor(x)</code></td>
			<td>возвращает наибольшее целое число, меньшее или равное <strong>x</strong></td>
			<td><code>floor(4.2)=4<br>
			floor(-5.8)=-6</code></td>
		</tr>
		<tr>
			<td><code>power(x, y)</code></td>
			<td>возведение <strong>x</strong> в степень<strong> y</strong></td>
			<td><code>power(3,4)=81.0</code></td>
		</tr>
		<tr>
			<td><code>sqrt(x)</code></td>
			<td>квадратный корень из&nbsp;<strong>x</strong></td>
			<td><code>sqrt(4)=2.0<br>
			sqrt(2)=1.41...</code></td>
		</tr>
		<tr>
			<td><code>degrees(x)</code></td>
			<td>конвертирует значение <strong>x</strong> из радиан в градусы</td>
			<td><code>degrees(3) = 171.8...</code></td>
		</tr>
		<tr>
			<td><code>radians(x)</code></td>
			<td>конвертирует значение <strong>x </strong>из градусов в радианы</td>
			<td><code>radians(180)=3.14...</code></td>
		</tr>
		<tr>
			<td><code>abs(x)</code></td>
			<td>модуль числа <strong>x </strong></td>
			<td><code>abs(-1) = 1<br>
			abs(1) = 1</code></td>
		</tr>
		<tr>
			<td><code>pi</code></td>
			<td>pi = 3.1415926...</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

```sql
SELECT title, price, (price*18/100)/(1+18/100) AS tax, price/(1+18/100) AS price_tax FROM book
```

**Выборка данных, вычисляемые столбцы, логические функции**

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF:

```IF(логическое_выражение, выражение_1, выражение_2)```

Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение ```выражения_1```, в противном случае –  значение ```выражения_2```. Все три параметра ```IF()``` являются обязательными.

Допускается использование вложенных функций, вместо ```выражения_1``` или ```выражения_2``` может стоять новая функция ```IF```.

**Пример**

Для каждой книги из таблицы book установим скидку следующим образом: если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.

*Запрос:*

```sql
SELECT title, amount, price, 
       IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```

```sql
SELECT author, title, 
       round(IF(author="Булгаков М.А.", price*1.1, IF(author="Есенин С.А.", price*1.05, price)),2) AS new_price
FROM book;
```

**Выборка данных по условию**


Логическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.

```sql
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

**Выборка данных, логические операции**

Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

- круглые скобки
- умножение  (*),  деление (/)
- сложение  (+), вычитание (-)
- операторы сравнения (=, >, <, >=, <=, <>)
- NOT
- AND
- OR

*Пример*

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

*Запрос:*

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

**Выборка данных, операторы BETWEEN, IN**

Логическое выражение после ключевого слова ```WHERE``` может включать операторы ```BETWEEN``` и ```IN```. Эти операторы имеют самый низкий приоритет (как  OR).

- Оператор ```BETWEEN``` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.
- Оператор  ```IN```  позволяет выбрать данные, соответствующие значениям из списка.

```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

**Выборка данных, оператор LIKE**

Оператор ```LIKE``` используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), ```LIKE``` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

<table border="1">
	<thead>
		<tr>
			<th><sup>Символ-шаблон</sup></th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><strong>%</strong></td>
			<td>Любая строка, содержащая ноль или более символов</td>
			<td><code>SELECT * FROM book WHERE author LIKE '%М.%' </code><br>
			выполняет поиск и выдает все книги, инициалы авторов которых содержат «<em>М.</em>»</td>
		</tr>
		<tr>
			<td><strong>_ </strong><sup>(подчеркивание)</sup></td>
			<td>Любой одиночный символ</td>
			<td><code>SELECT * FROM book WHERE title LIKE 'Поэм_' </code><br>
			выполняет поиск и выдает все книги, названия которых либо «<em>Поэма</em>», либо «<em>Поэмы</em>» и пр.</td>
		</tr>
	</tbody>
</table>

*Пример*: Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С».

**Выборка данных с сортировкой**

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ```ORDER BY```, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ```ORDER BY``` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ```ASC``` (по возрастанию) или ```DESC``` (по убыванию). 

Логический порядок операций для запроса SQL следующий:

- FROM
- WHERE
- SELECT
- ORDER BY
- Поскольку сортировка выполняется позже SELECT, для указания столбцов, по которым выполняется сортировка, можно использовать имена, присвоенные им после SELECT, а также порядковый номер столбца в перечислении.

## Запросы, групповые операции

**Выбор различных элементов столбца**

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово ```DISTINCT```, которое размещается сразу после ```SELECT```.


```sql
SELECT DISTINCT author
FROM book;
```

*Результат*

```
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

**Выборка данных, групповые функции SUM и COUNT**

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

При группировке данных таблицы ```book``` по столбцу ```author```,  получается три группы. В первую группу входят две строки, в поле ```author``` которых стоит значение «Булгаков М.А.». В столбце amountк этой группе относится значения 3 и 5.  Просуммировав эти значения, можно узнать общее количество книг Булгакова на складе. Для этого используется групповая функция ```SUM()```. В скобках указывается столбец, по которому осуществляется суммирование.

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

*Результат*

```
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

Также групповые функции позволяют посчитать сколько записей относится к каждой группе, для этого используется функция ```count()```

**Примечание.**  Из таблицы с результатами запроса видно, что функцию ```COUNT()```  можно применять к любому столбцу, в том числе можно использовать и ```*```, если таблица не содержит пустых значений. Если же в столбцах есть значения ```Null```, то

- COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
- COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.
- **ВАЖНО**. После оператора GROUP BY должны перечисляться ВСЕ неагрегированные столбцы (то есть столбцы, к которым не применены групповые функции), указанные после SELECT.

*Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе. Вычисляемые столбцы назвать Различных_книг и Количество_экземпляров соответственно, столбец с фамилиями авторов назвать Автор.*

```sql
SELECT author as Автор, COUNT(*) AS 'Различных_книг', SUM(amount) as 'Количество_экземпляров'
FROM book
GROUP BY author;
```

**Выборка данных, групповые функции MIN, MAX и AVG**

К групповым функциям SQL относятся: ```MIN()```, ```MAX()``` и ```AVG()```, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

```sql
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```

**Выборка данных c вычислением, групповые функции**

В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

```sql
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

**Выборка данных по условию, групповые функции**

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после ```WHERE```. В запросах с групповыми функциями вместо ```WHERE``` используется ключевое слово ```HAVING``` , которое размещается после оператора ```GROUP BY```.

*Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.*

```sql
SELECT author,
       MIN(price) AS Минимальная_цена, 
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price*amount) > 5000; 
```

*Вычислить среднюю цену и суммарную стоимость тех книг, количество которых принадлежит интервалу от 5 до 14, включительно. Столбцы переименовать как показано в образце, значения округлить до 2-х знаков после запятой.*

```sql
SELECT round(AVG(price),2) AS Средняя_цена, sum(price*amount) AS Стоимость
FROM book
WHERE amount BETWEEN 5 AND 14;
```

**Выборка данных по условию, групповые функции, WHERE и HAVING**

```WHERE``` и ```HAVING``` могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения SQL запроса на выборку на сервере:

- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY

Сначала определяется таблица, из которой выбираются данные (```FROM```), затем из этой таблицы отбираются записи в соответствии с условием  ```WHERE```, выбранные данные агрегируются (GROUP BY),  из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING. Потом формируются данные результирующей выборки, как это указано после ```SELECT``` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после O```RDER BY```.

**Пример**

Вывести максимальную и минимальную цену книг всех авторов, кроме Есенина, количество экземпляров книг которых больше 10. 


```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
WHERE author <>'Есенин С.А.'
GROUP BY author
HAVING SUM(amount)>10;
```

## Вложенные запросы

**Вложенный запрос, возвращающий одно значение**

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.

*Пример*

Вывести информацию о самых дешевых книгах, хранящихся на складе. Для реализации этого запроса нам необходимо получить минимальную цену из столбца price таблицы book, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (SELECT MIN(price) FROM book);
```

```
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```

Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.

**Использование вложенного запроса в выражении**

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, отнять и пр.

Пример

Вывести информацию о книгах, количество которых отличается от среднего количества книг на складе более чем на 3. То есть нужно вывести и те книги, количество которых меньше среднего на 3, и больше среднего на 3.

```sql
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```

```
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```

**Вложенный запрос, оператор IN**

Вложенный запрос может возвращать несколько значений одного столбца.  Оператор ```IN``` определяет, совпадает ли указанное в логическом выражении значение с одним из значений, содержащихся во вложенном запросе ,  при этом логическое выражение получает значение истина. Оператор ``NOT IN`` выполняет обратное действие – выражение истинно, если значение не содержится во вложенном запросе.

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.


```sql
SELECT title, author, amount, price
FROM book
WHERE author IN (SELECT author FROM book GROUP BY author having SUM(amount) >= 12);
```

```
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```

**Вложенный запрос, операторы ANY и ALL**

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы ```ANY``` и ```ALL``` используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ```ANY()```:

- ```amount > ANY (10, 12)``` эквивалентно ```amount > 10```
- ```amount < ANY (10, 12)``` эквивалентно ```amount < 12```
- ```amount = ANY (10, 12)``` эквивалентно ```(amount = 10) OR (amount = 12)```, а также amount ```IN (10,12)```
- ```amount <> ANY (10, 12)``` вернет все записи с любым значением ```amount```, включая 10 и 12

При использовании оператора ```ALL``` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ```ALL```:

- ```amount > ALL (10, 12)``` эквивалентно ```amount > 12```
- ```amount < ALL (10, 12)``` эквивалентно amount < 10
- ```amount = ALL (10, 12)``` не вернет ни одной записи, так как эквивалентно ```(amount = 10) AND (amount = 12)```
- ```amount <> ALL (10, 12)``` вернет все записи кроме тех,  в которыхamount равно 10 или 12

Важно! Операторы ```ALL``` и ```ANY``` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

**Пример:** *Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не меньше 12.*

```sql
SELECT title, author, amount, price
FROM book
WHERE author = ANY (SELECT author FROM book GROUP BY author having SUM(amount) >= 12);
```

```
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```


**Добавление записей из другой таблицы**

```sql
INSERT INTO book (title, author, price, amount) 
       SELECT title, author, price, amount 
       FROM supply;

SELECT * FROM book;
```

## Связи между таблицами

Рассмотрим таблицу ```book```

<h2>Связь&nbsp;«один ко многим»</h2>

<p>Рассмотрим таблицу<strong><code> book</code></strong>(в ней столбец <code><strong>author</strong></code> переименован в <code><strong>name_author</strong></code>):</p>

<table cellspacing="0" cellpadding="0" border="1">
	<tbody>
		<tr style="background-color: #a9a9a9; background: #a9a9a9; text-align: center;">
			<td><strong>book_id</strong></td>
			<td><strong>title</strong></td>
			<td><strong>name_author</strong></td>
			<td><strong>price</strong></td>
			<td><strong>amount</strong></td>
		</tr>
		<tr>
			<td>1</td>
			<td>Мастер и Маргарита</td>
			<td>Булгаков М.А.</td>
			<td>670.99</td>
			<td>3</td>
		</tr>
		<tr>
			<td>2</td>
			<td>Белая гвардия</td>
			<td>Булгаков М.А.</td>
			<td>540.50</td>
			<td>5</td>
		</tr>
		<tr>
			<td>3</td>
			<td>Идиот</td>
			<td>Достоевский Ф.М.</td>
			<td>460.00</td>
			<td>10</td>
		</tr>
		<tr>
			<td>4</td>
			<td>Братья Карамазовы</td>
			<td>Достоевский Ф.М.</td>
			<td>799.01</td>
			<td>2</td>
		</tr>
		<tr>
			<td>5</td>
			<td>Стихотворения и поэмы</td>
			<td>Есенин С.А.</td>
			<td>650.00</td>
			<td>15</td>
		</tr>
	</tbody>
</table>

<p>В этой таблице фамилии авторов повторяются для нескольких книг. А что, если придется вместо инициалов для каждого автора хранить его полное имя и отчество? Тогда, если в таблице содержится информация о 50 книгах Достоевского, придется 50 раз исправлять «Ф.М.» на «Федор Михайлович». При этом, если в некоторых записях использовать «Фёдор Михайлович» (c буквой ё), то мы вообще получим двух разных авторов...&nbsp;</p>

<p>Чтобы устранить эту проблему в реляционных базах данных создается новая таблица <code><strong>author</strong></code>,&nbsp; в которой перечисляются все различные авторы, а затем эта таблица связывается с таблицей <code><strong>book</strong></code>. При этом такая связь называется «<strong>один ко многим</strong>», таблица <code><strong>author</strong></code> называется главной, таблица<code><strong> book </strong></code>– связанной или подчиненной.&nbsp;</p>

<p>Связь&nbsp;«<strong>один ко многим</strong>» имеет место, когда одной записи&nbsp;главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы&nbsp;соответствует только одна запись главной таблицы. Обозначается это так:</p>

<p><img alt="" src="https://ucarecdn.com/3a1dee13-b46f-476e-82ee-d3c0a99ef729/"></p>

<p><strong>Этапы реализации связи </strong>«<strong>один ко многим</strong>»</p>

<p>Исходная таблица:</p>

<p><img alt="" src="https://ucarecdn.com/48c40062-8c77-4ef1-995e-5eec3e697b36/"></p>

<p>1. Создать таблицу <code><strong>author</strong></code> ,&nbsp; в которую включить всех различных авторов из таблицы <code><strong>book</strong></code> (а затем удалить столбец с фамилиями авторов из таблицы <code><strong>book</strong></code>):</p>

<p><img alt="" src="https://ucarecdn.com/ebb2959d-32be-4d80-8855-abe8ce6ec4cb/"></p>

<p>2. Обе таблицы должны содержать первичный ключ, в таблице&nbsp; <code><strong>book</strong></code>он уже есть,&nbsp; в таблицу <code><strong>author</strong></code>добавим ключ&nbsp;<code><strong>author_id</strong></code>:</p>

<p><img alt="" src="https://ucarecdn.com/88d82e42-3e5b-4e9a-b8e0-78f27f348b1b/"></p>

<p>3. Включить в таблицу <code><strong>book</strong></code> связанный столбец (внешний ключ,&nbsp;<code><strong>FOREIGN KEY</strong></code>), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец<code><strong> author_id</strong></code>). Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы:</p>

<p><img alt="" src="https://ucarecdn.com/d504072b-bad1-4040-8f49-f5b7102fa1ca/"></p>

<h2>Связь «многие ко многим»</h2>

<p>На предыдущем шаге мы реализовали связь «<strong>один ко многим</strong>» для книг и авторов. Она означает, что каждый автор написал несколько книг, но каждую книгу написал только один автор. На самом деле, это не совсем верное утверждение. Например, книга «12 стульев» написана двумя авторами Ильфом И.А. и Петровым Е.П. С другой стороны, эти авторы написали и другие книги, например «Золотой теленок».</p>

<p>Для соединения таких таблиц используется связь «<strong>многие ко многим</strong>».</p>

<p>Связь «<strong>многие ко многим</strong>» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой. Обозначается это так:</p>

<p><img alt="" src="https://ucarecdn.com/e53a7a38-0b4e-4705-b07e-209dd8074e49/"></p>

<p><strong>Этапы реализации связи </strong>«<strong>многие ко многим</strong>»</p>

<p>Исходная таблица:</p>

<p><img alt="" src="https://ucarecdn.com/48c40062-8c77-4ef1-995e-5eec3e697b36/"></p>

<p>1. Создать таблицу <code><strong>author</strong></code>,&nbsp; в которую включить всех различных авторов из таблицы <code><strong>book</strong></code> (а затем удалить столбец с фамилиями авторов из таблицы <code><strong>book</strong></code>):</p>

<p><img alt="" src="https://ucarecdn.com/3762c894-7798-4ff7-a254-4068635de34e/"></p>

<p>2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице<strong> <code>book</code></strong> он уже есть, поэтому достаточно включить первичный ключ <strong><code>author_id</code>&nbsp;</strong>в таблицу&nbsp;<code><strong>author</strong></code>:</p>

<p><img alt="" src="https://ucarecdn.com/961abd2a-0a7c-42c4-ab52-b4e9cb2d9ceb/"></p>

<p>3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. Каждый из этих столбцов является внешним ключом&nbsp;(<code><strong>FOREIGN KEY</strong></code>)&nbsp; и связан с&nbsp;ключевым столбцом каждой таблицы.&nbsp;Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы.</p>

<p><img alt="" src="https://ucarecdn.com/6943bc53-bbe5-410b-9264-00b20eb0f017/"></p>

<p>4. Дальше необходимо определиться с первичным ключом таблицы-связки. Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, например, если мы будем продавать книги покупателям (один человек может купить несколько книг, а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, например, дату продажи,&nbsp; также в таблицу-связку добавляют первичный ключ. Мы воспользуемся вторым способом:</p>

<p><img alt="" src="https://ucarecdn.com/9e4529dc-355a-4675-a782-a824fd11d4ce/"></p>

## Соединение INNER JOIN

<h2>Внешнее соединение&nbsp;LEFT и RIGHT OUTER JOIN</h2>

<p>Оператор внешнего&nbsp;соединения <code>LEFT OUTER JOIN</code>&nbsp; (можно использовать <code>LEFT&nbsp;JOIN</code>) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.</p>

<pre><code class="language-sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>
 ...
<span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>
 таблица_1 <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span>  таблица_2
 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> условие
...</code></pre>

<p>Результат запроса формируется так:</p>

<ol>
	<li>в результат включается внутреннее соединение (<code>INNER JOIN</code>) первой и второй&nbsp;таблицы в соответствии с условием;</li>
	<li>затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй&nbsp;таблицы заполняются значениями <code>NULL</code>.</li>
</ol>

<p>Соединение <code>RIGHT&nbsp;JOIN</code> действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.</p>

<p><strong>Пример</strong></p>

<p>Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать <code>Null</code>.</p>

<p><em>Запрос:</em></p>

<pre><code class="language-sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> name_author, title 
<span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> author <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> book
     <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> author.author_id = book.author_id
<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> name_author;     </code></pre>

<p>Результат:</p>

<pre><code class="language-sql hljs">+<span class="hljs-comment"><span class="hljs-comment">------------------+-----------------------+</span></span>
| name_author      | title                 |
+<span class="hljs-comment"><span class="hljs-comment">------------------+-----------------------+</span></span>
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | None                  |
| Пастернак Б.Л.   | Лирика                |
+<span class="hljs-comment"><span class="hljs-comment">------------------+-----------------------+</span></span></code></pre>

<p>Так как в таблице<code><strong> book</strong></code> нет книг Лермонтова, напротив этой фамилии стоит <code>Null (None)</code>.</p>

<h2>Задание</h2>

<p>Вывести все жанры, книг которых нет на складе.</p>

<p><strong>Логическая схема базы данных:</strong></p>

<p><img alt="" src="https://ucarecdn.com/95045d96-412d-4e10-88f2-7ac6b13fada6/"></p>

<p><em>Результат:</em></p>

<pre><code class="language-sql hljs">+<span class="hljs-comment"><span class="hljs-comment">-------------+</span></span>
| name_genre  |
+<span class="hljs-comment"><span class="hljs-comment">-------------+</span></span>
| Приключения |
+<span class="hljs-comment"><span class="hljs-comment">-------------+</span></span></code></pre>

<p><strong>Пояснение. </strong>При использовании внешнего соединения названия книг и другие&nbsp;столбцы таблицы <code><strong>book </strong></code>для жанра тех книг, которого нет на складе, будут содержать значение&nbsp;<code>Null</code>.</p>





```sql

```


```sql

```


```sql

```


```sql

```


```sql

```


